!function(t){
	const i = {}; function n(e){
		if (i[e]) return i[e].exports; const r = i[e] = {i:e, l:!1, exports:{}}; return t[e].call(r.exports, r, r.exports, n), r.l = !0, r.exports
	}n.m = t, n.c = i, n.d = function(t, i, e){
		n.o(t, i) || Object.defineProperty(t, i, {enumerable:!0, get:e})
	}, n.r = function(t){
		'undefined' != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {value:'Module'}), Object.defineProperty(t, '__esModule', {value:!0})
	}, n.t = function(t, i){
		if (1 & i && (t = n(t)), 8 & i) return t; if (4 & i && 'object' == typeof t && t && t.__esModule) return t; const e = Object.create(null); if (n.r(e), Object.defineProperty(e, 'default', {enumerable:!0, value:t}), 2 & i && 'string' != typeof t) for (const r in t)n.d(e, r, (i => {
			return t[i]
		}).bind(null, r)); return e
	}, n.n = function(t){
		const i = t && t.__esModule ? function(){
			return t.default
		} : function(){
			return t
		}; return n.d(i, 'a', i), i
	}, n.o = function(t, i){
		return Object.prototype.hasOwnProperty.call(t, i)
	}, n.p = '', n(n.s = 0)
}([function(t, i, n){
	t.exports = n(1)
}, function(t, i, n){
	const e = n(2); t.exports = {initBrowserHost:function(t){
		return function(t, i){
			if (t !== i) throw new TypeError('Cannot instantiate an arrow function')
		}(this, this), e.init(t)
	}.bind(this)}
}, function(t, i, n){
	'use strict'; function e(t, i){
		if (t !== i) throw new TypeError('Cannot instantiate an arrow function')
	} const r = n(3), s = {moreLogs:'', includeLogs:'', extraIgnoredEvents:[], MAX_LOG_SIZE:1e4, DEFAULT_LOGS_COUNT:300, GROUP_MIN_LEN:5, stackFilter:/wSpy/i}; function o(){
		return 'undefined' != typeof window && void 0 !== window.parent
	}t.exports = {init:function(t){
		const i = t.wSpyOverrideParam, n = t.settings, u = o(), c = u ? i || function(t){
				if ('undefined' != typeof URL){
					const i = new URL(t); return i.searchParams.get('wspy') || i.searchParams.get('wSpy')
				}
			}(window.parent.location.href) : null, h = r.init(u ? {Error:window.Error, memoryUsage:function(){
				return e(this, this), window.performance.memory.usedJSHeapSize
			}.bind(this), frame:window, wSpyParam:c, settings:Object.assign({}, s, n)} : {}), a = {}; if (Object.keys(h).forEach(t => {
			return e(this, this), a[t] = function(){
				e(this, this)
			}.bind(this)
		}), !c) return a; try {
			const t = function(){
				try {
					return o() && void 0 !== window.parent.wSpy && window.parent.wSpy
				} catch (t){
					return !1
				}
			}(); return t ? (h.initStack = (new Error).stack, h.logs = t.logs || h.logs, (t.ver || 0) < h.ver ? (t.logs = h.logs, h.otherSpies = [t, ...t.otherSpies || []], window.parent.wSpy = h) : t.otherSpies.push(h), h) : u ? (window.parent.wSpy = h, h.initStack = (new Error).stack, h) : a
		} catch (t){
			return a
		}
	}}
}, function(t, i, n){
	'use strict'; function e(t, i){
		if (t !== i) throw new TypeError('Cannot instantiate an arrow function')
	} const r = ['index', 'time', '_time', 'mem', 'source']; function s(t){
		return 'string' == typeof t || t instanceof String
	} function o(t){
		const i = t.Error, n = t.frame, o = t.settings, u = t.wSpyParam, c = t.memoryUsage; return {ver:4, logs:{}, otherSpies:[], init(){
			if (!this.includeLogs){
				const t = (u || '').split(',').filter(t => {
						return e(this, this), '-' !== t[0]
					}).filter(t => {
						return e(this, this), t
					}), i = (u || '').split(',').filter(t => {
						return e(this, this), '-' === t[0]
					}).map(t => {
						return e(this, this), t.slice(1)
					}); this.includeLogs = o.includeLogs.split(',').concat(t).filter(t => {
					return e(this, this), -1 === i.indexOf(t)
				}).reduce((t, i) => {
					return e(this, this), t[i] = !0, t
				}, {})
			}
		}, shouldLog(t, i){
			return Array.isArray(i) && this.includeLogs[t] && !o.extraIgnoredEvents.includes(i[0])
		}, log(t, i, n){
			if (this.init(), !this.shouldLog(t, i)) return; this.logs.index = this.logs.index || 1, this.logs[t] = this.logs[t] || [], i.index = this.logs.index++, i.source = this.source(n); const e = new Date; i._time = `${e.getSeconds()}:${e.getMilliseconds()}`, i.time = e.getTime(), i.mem = c() / 1e6, this.logs[t].length > o.MAX_LOG_SIZE && (this.logs[t] = this.logs[t].slice(-1 * Math.floor(o.MAX_LOG_SIZE / 2))), !i[0] && i.source && (i[0] = i.source[0]), this.logs[t].push(i)
		}, getCallbackName(t, i){
			if (t){
				if (!t.name || s(t.name) && t.name.startsWith('bound ')){
					if (Array.isArray(t.source)) return t.source[0]; const n = this.source(i); if (Array.isArray(n)) return n
				} return t.name.trim()
			}
		}, search(t){
			return function(t){
				return '[object RegExp]' === Object.prototype.toString.call(t)
			}(t) ? this.merged(i => {
					return e(this, this), t.test(i.join(' '))
				}) : s(t) ? this.merged(i => {
					return e(this, this), -1 !== i.join(' ').indexOf(t)
				}) : Number.isInteger(t) ? this.merged().slice(-1 * t) : void 0
		}, logCallBackRegistration(t, i, n, e){
			t.source = this.source(e), this.log(i, [this.getCallbackName(t, e), ...n], e)
		}, logCallBackExecution(t, i, n, e){
			this.log(i, [this.getCallbackName(t, e), t.source, ...n], e)
		}, spyMobx(t){
			t.spy(t => {
				if (e(this, this), !t.spyReportEnd && 'update' === t.type){
					const i = this.source(); this.log('mobx', [`update: ${t.name}`, ...i, t.newValue, t])
				}
			})
		}, purge(t){
			const i = -1 * (t || o.DEFAULT_LOGS_COUNT); Object.keys(this.logs).forEach(t => {
				return e(this, this), this.logs[t] = this.logs[t].slice(i)
			})
		}, clear(){
			Object.keys(this.logs).forEach(t => {
				return e(this, this), this.logs[t] = []
			})
		}, recent(t){
			const i = -1 * (t || o.DEFAULT_LOGS_COUNT); return this.merged().slice(i)
		}, merged(t){
			return [].concat.apply([], Object.keys(this.logs).filter(t => {
				return e(this, this), Array.isArray(this.logs[t])
			}).map(t => {
				return e(this, this), this.logs[t].map(i => {
					e(this, this); const n = [i.index, t, ...i]; return r.forEach(t => {
						e(this, this), n[t] = i[t]
					}), n
				})
			})).filter((i, n, r) => {
				return e(this, this), !t || t(i, n, r)
			}).sort((t, i) => {
				return e(this, this), t.index - i.index
			})
		}, grouped(t){
			const i = this.merged(t), n = -1 * o.DEFAULT_LOGS_COUNT; return [].concat.apply([], i.reduce((t, i, n, s) => {
				e(this, this); const u = t[t.length - 1]; return u ? (i[1] === u[0][1] ? u.push(i) : (u.length > o.GROUP_MIN_LEN && u.unshift(`[${u.length}] ${u[0][1]}`), t.push(r(i))), n === s.length - 1 && u.length > o.GROUP_MIN_LEN && u.unshift(`[${u.length}] ${u[0][1]}`), t) : [r(i)]
			}, []).map(t => {
				return e(this, this), t.length > o.GROUP_MIN_LEN ? [t] : t
			})).slice(n).map((t, i, n) => {
				e(this, this); const r = 0 === i ? 0 : t.time - n[i - 1].time; return t[0] = `${t[0]} +${r}`, t
			}); function r(t){
				const i = [t]; return i.time = t.time, i
			}
		}, groupedNoMobx(t){
			return this.grouped((i, n, r) => {
				return e(this, this), 'mobx' !== i[1] && (!t || t(i, n, r))
			})
		}, source(t){
			i.stackTraceLimit = 50; const r = [n]; for (;r[0].parent && r[0] !== r[0].parent;)r.unshift(r[0].parent); let s = r.reverse().map(t => {
				return e(this, this), (new t.Error).stack
			}).join('\n').split(/\r|\n/).map(t => {
				return e(this, this), t.trim()
			}).slice(4).filter(t => {
				return e(this, this), 'Error' !== t
			}).filter(t => {
				return e(this, this), !o.stackFilter.test(t)
			}); if (t){
				const i = s.findIndex(i => {
					return e(this, this), -1 !== i.indexOf(t)
				}); s = s.slice(i + 1)
			} const u = s[0] || ''; return [u.split(/at |as /).pop().split(/ |]/)[0], u.split('/').pop().slice(0, -1).trim(), ...s]
		}}
	}t.exports = {init:function(t){
		return e(this, this), o(t)
	}.bind(this)}
}])